import process from 'process';
import readline from 'readline';
import fs from 'fs';
import path from 'path';
import { cmd, sleep, move, print, line, repeat, color } from 'jb-node-lib';
import { red, green, yellow, blue, gray, grayDark, cyan, black, brown, white } from 'jb-node-lib';

const rl = readline.createInterface({ input: process.stdin,  output: process.stdout, });
function ask(text) { return new Promise((resolve) => rl.question(text, (answer) => resolve(answer))); }


/*******************************************************************************************
 Param1: Target folder to copy
 Param2: Base destination path where to copy
 A new folder with the name of the original folder will be created on "Param2" path.
 Add to .bashrc: alias copy="node ~/joel_scripts/copy.js $1 $2"
 
 Example:
    copy /home/barba/DEV/JB-PIANO /media/DISK12/PROGRAMES_PROPIS --run
  
 This will create a new folder ------> /media/DISK12/PROGRAMES_PROPIS/JB-PIANO  and copy *.* within
*******************************************************************************************/

const DIR_NAME = process.argv[2] || 'node_modules'; // Name of the folder to find and remove


console.log(`Scanning: Looking recursively for ${yellow(DIR_NAME)} in ${green(process.cwd())}...`);
const res = analyseDir();
console.log('');
console.log(`  - Current folder = ${green(process.cwd())}`);
console.log(`  - Total size = ${yellow(formatSize(res.totalSize))} (${res.files.length} files, ${res.dirs.length} directories)`);
console.log(`  - There are ${res.nmDirs + ' ' + red(DIR_NAME)} directories with a total size of: ${yellow(formatSize(res.nmSize))}`);
if (res.nmDirs > 0) {
  const numSpaces = (res.nmDirs + '').split('').map(v => ' ').join('')
  console.log(numSpaces + '                │');
  const q = await ask(numSpaces + `                └───> Remove them all? (${cyan('Enter')} = yes)`);
  if (!q) { await removeModules(); }
}

console.log('');
process.exit(0);



function analyseDir(rootDir = process.cwd()) {
  const allFiles = []; // Global list with all recursively scanned files and subdirectories
  const nmFiles = []; // Files in node_modules
  
  const totalSize = checkDir(rootDir, 10);
  
  function checkDir(dir, deep = 0) {
    // console.log('Checking', dir);
    if (deep > 20) { return 0; }
    let size = 0;
    getDirList(dir).forEach(file => {
      allFiles.push(file);
      if (file.type === 'dir') {
        file.size = checkDir(file.path, deep + 1); // recursive check to subdirectory
        if (file.name === DIR_NAME) { nmFiles.push(file); }
      };
      size += file.size;
    });
    return size;
  }

  return { 
    totalSize,
    files     : allFiles.filter(f => f.type === 'file'),
    dirs      : allFiles.filter(f => f.type === 'dir'),
    nmSize    : nmFiles.reduce((acc, file) => file.size + acc, 0),
    nmDirs    : nmFiles.filter(f => f.type === 'dir').length,
  };


  

  const files = allFiles.filter(f => f.type === 'file');
  const dirs = allFiles.filter(f => f.type === 'dir');

  const nmSize = nmFiles.reduce((acc, file) => file.size + acc, 0);

  // console.log(` - Total Size    : ${yellow(formatSize(totalSize))}`);
  // console.log(` - Total Files   : ${yellow(files.length)}`);
  // console.log(` - Total Subdirs : ${yellow(dirs.length)}`);

  // console.log(` - node_modules Size    : ${yellow(formatSize(nmSize))}`);
  // console.log(` - node_modules Files   : ${yellow(nmFiles.filter(f => f.type === 'file').length)}`);
  // console.log(`There are ${yellow(nmFiles.filter(f => f.type === 'dir').length)} ${red('node_module')} directories with a total size of: ${yellow(formatSize(nmSize))}`);
}





async function removeModules(rootDir = process.cwd()) {
  console.log('');
  await checkDir(rootDir);
  const res = analyseDir();
  console.log('');
  console.log(`  - Total size after = ${yellow(formatSize(res.totalSize))} (${res.files.length} files, ${res.dirs.length} directories)`);
  console.log('');
  async function checkDir(dir, deep = 0) {
    if (deep > 20) { return 0; }
    const dirs = getDirList(dir);
    for (let t = 0; t < dirs.length; t++) {
      const file = dirs[t];
      // console.log(file.path);
      if (file.type === 'dir') {
        if (file.name === DIR_NAME) {
          console.log(red(`rm -rf ${file.path}`));
          await cmd(`rm -rf ${file.path}`);
        } else {
          await checkDir(file.path, deep + 1);
        }
      };
    }
  }
}




// ----------------------------------------------------------


function dirExist(fullPath) { // Check if a directory exists
  try {
    if (fs.existsSync(fullPath)) { return true; }
  } catch(err) { return false; }
}
function formatTime(ms) {
  if (ms < 1000) { return `00:00`; }
  if (ms < 60000) {
    const sec = Math.round(ms / 1000);
    return `00:${pad(sec, 2, '0')}`;
  }
  const min = Math.floor(ms / 60000);
  const sec = Math.round((ms - (min * 60000)) / 1000);
  return `${pad(min, 2, '0')}:${pad(sec, 2, '0')}`;
}

function formatSize(size = 0) {
  const KB = Math.pow(1024, 1);
  const MB = Math.pow(1024, 2);
  const GB = Math.pow(1024, 3);
  if (size < KB) { return `${size}  B`; }
  if (size < MB) { return `${Math.floor(10 * size / KB) / 10} KB`; }
  if (size < GB) { return `${Math.floor(10 * size / MB) / 10} MB`; }
  return `${Math.floor(10 * size / GB) / 10} GB`;
}



function getDirList(dir, addHidden = true) {  // dir should be the full path
  try {
    const list = [];
    const files = fs.readdirSync(dir);
    for (let file of files) {
      const fullPath = path.join(dir, file);
      if (!fs.existsSync(fullPath)) { // In case of broken Symlink
        // console.log('Broken Symlink (skipping) --> ', fullPath);
      } else {
        const fileStat = fs.statSync(fullPath);
        if (addHidden || file[0] !== '.') {
          if (fileStat.isFile()) {
            list.push({ type: 'file', name: file, path: fullPath, size: fileStat.size });
          } else if (fileStat.isDirectory()) {
            list.push({ type: 'dir', name: file, path: fullPath, size: 0 });
          }
        }
      }
    }
    return list;

  } catch(err) { console.log('ERROR', err); process.exit(1); }    
}
